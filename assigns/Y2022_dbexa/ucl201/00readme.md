

Software Process

```
A Software Process is a set of activities whose goal is the development or evolution of software
Fundamental activities in all software processes are:

Specification - what the system should do and its development 	constraints
Development - production of the software system (design and 	implementation) 
Validation - checking that the software is what the customer wants
Evolution - changing the software in response to changing demands

```

the Attributes of Good Software

```
The software should deliver the required functionality and performance to the user and should be maintainable, dependable, efficient and usable.

Maintainability
Software must (easily) evolvable to meet changing needs
Dependability
Software must be trustworthy (work with all data)
Efficiency
Software should not make wasteful use of system resources
Usability
Software must be usable by the users for which it was designed

```

Issues of Professional Responsibility

```
Confidentiality 
Engineers should normally respect the confidentiality of their employers or clients even without a formal confidentiality agreement.
Competence 
Engineers should not misrepresent their level of competence. They should not knowingly accept work which is beyond their competence.
Intellectual property rights 
Engineers should be careful to ensure that the intellectual property of employers and clients is protected and know the local laws governing IP.
Computer misuse 
Software engineers should not use their technical skills to misuse other people’s computers.

```

**Software development process – software life cycle**

```
Coherent sets of activities for 
Specifying, 
Designing, 
Implementing and 
Testing software systems

```

Software Process Models

```
The Waterfall Model (classic engineering, example bridge building)   
Separate and distinct phases of specification and development
Evolutionary Development (more like product engineering)
Specification and development are interleaved
Agile and Scrum
Used widely in industry today


The drawback of the waterfall model is the difficulty of accommodating change after the process is underway
Inflexible partitioning of the project into distinct stages
This makes it difficult to respond to changing customer requirements
Therefore, this model is only appropriate when the (final) requirements are well-understood (rare in software)
Waterfall model describes a process of stepwise refinement
Based on hardware engineering models 
Widely used in military and aerospace industries
```

Evolutionary Development

```
Rather than using the waterfall model we may use evolutionary development which is based upon the idea of developing an initial implementation , exposing it to the user and refining it based upon their response. 
Exploratory development 
Objective is to work with customers and to evolve a final system from an initial outline specification. 
Should start with well-understood requirements. 
The system evolves by adding new features as they are proposed by customer. 


Problems
Lack of process visibility
Systems are sometimes poorly structured
Applicability
All types of system but rare in safety critical

```



Agile development

```
Lightweight approach to software development
Example include Scrum and XP
Focused on
Code development as code activity
Test driven development (tests developed before code)
Often use pair programming
Iterative development
Self organised teams

```

Incremental Development
 (Scrum)

```
Rather than deliver the system as a single delivery, the development and delivery is broken down into increments (SCRUM sprints) with each increment delivering part of the required functionality
User requirements are prioritised and the highest priority requirements are included in early increments
Once the development of an increment is started, the requirements are frozen though requirements for later increments can continue to evolve

Incremental Development Advantages:

Customer value can be delivered with each increment so system functionality is available earlier
Early increments act as a prototype to help elicit requirements for later increments
Lower risk of overall project failure
The highest priority system services tend to receive the most testing

Most software processes involve
Prototyping
Iterative building
Why
It reduces risk of making the wrong product
It allows the software to undergo more testing
It produces working product as we go along, so less chance of inventory loss


```





```
Validation confirms the software is good for the end user, verification confirms it works 
according to the specification
```

